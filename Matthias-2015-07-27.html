<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="pandoc.css" type="text/css" />
</head>
<body>
<p>Started in the 30s with Church.</p>
<p>Godel has a language that can prove anything.</p>
<p>Church says you can prove anything with functions.</p>
<p>Set notation was <code>^ x | x¬≤ &lt; 0</code>, church annotated <code>'^ | x¬≤ &lt; 0</code>, which was typeset as <code>Œª | x¬≤ &lt; 0</code>.</p>
<pre><code>e ‚©¥ x | Œªx.e | e e</code></pre>
<p>See things as trees:</p>
<pre><code>((Œªx.x)(Œªx.x)) = (Œª.‚Üê) (Œª.‚Üê)</code></pre>
<p>The names don't matter, the meaning of variable is its binding-site.</p>
<pre><code>Œªdavid. (david david) = Œªjeff. (jeff jeff)</code></pre>
<p>&quot;<code>Œª</code> is just 7th-grade algebra hyped up a little bit.&quot;</p>
<pre><code>f(x) ‚âî x¬≤

f(6) + 5 = 6¬≤ + 5 = 41

(Œªx.e)e&#39; = e[x‚Üêe&#39;] -- Œ≤

(Œªx.x) a = a

(Œªxy.xyy)ab = (Œªy.ayy)b = abb</code></pre>
<p>Lambdas are not functions! What about partial functions?</p>
<p><code>Œ≤</code> is a relation, and requires a <code>Œª</code> on the outside.</p>
<pre><code>Œªx.Œªy.Œªz.‚∏§(Œªx.x)(zz)‚∏•y</code></pre>
<p>We can't reduce with <code>Œ≤</code>.</p>
<p><code>Œ≤</code> is a &quot;notion of reduction&quot;.</p>
<p>We start defining <code>=‚∏§Œ≤‚∏£</code>:</p>
<pre><code>e Œ≤ e&#39;
---------
e =‚∏§Œ≤‚∏• e&#39;

e =‚∏§Œ≤‚∏• e&#39;
---------------
Œªx.e =‚∏§Œ≤‚∏• Œªx.e&#39;</code></pre>
<p>Template structure is called a &quot;redex&quot;.</p>
<p>[&quot;redex&quot; is not latin, it just means reducible expression. &quot;contractum&quot; is latin.]</p>
<p>Need another set of rules..</p>
<pre><code>e =‚∏§Œ≤‚∏• e&#39;
----------------
e‚ÇÄ e =‚∏§Œ≤‚∏• e‚ÇÄ e&#39;

e =‚∏§Œ≤‚∏• e&#39;
----------------
e e‚ÇÄ =‚∏§Œ≤‚∏• e&#39; e‚ÇÄ</code></pre>
<p>We are creating a &quot;syntactic compatibility closure&quot;.</p>
<p>We also need the reflexive, symmetric and transitive closure of <code>=‚∏§Œ≤‚∏•</code>.</p>
<p>This gives an equivalence relation.</p>
<p>We have &quot;a system of calculating equivalences between terms&quot;.</p>
<p>Q: &quot;does something have meaning?&quot;</p>
<p>Two possible meanings:</p>
<ol style="list-style-type: decimal">
<li>&quot;Can you prove 'true = false', or 'is everything related'&quot; You need to prove (meta-proof), that you cannot prove (in the system), that some two terms are equal. This is called a consistency theorem, developed by Church+Rosser, &quot;the Church+Rosser lemma&quot;. This shows that the system relates some terms, but not all terms.</li>
<li>Is there a topologically, algebraically generated space of functions generated by <code>Œª</code> and satisfying <code>=‚∏§Œ≤‚∏•</code>. This was worked out by Dana Scott.</li>
</ol>
<p>&quot;lambda-calculus and denotational semantics had a terrible influence on computer science&quot; --MF</p>
<p>1958: Lisp and Algol 60 were created.</p>
<p>Lisp: - introduced <code>Œª</code>-notation, got it wrong</p>
<p>Algol 60: - based on substitution model of <code>Œª</code>-calculus - call-by-name parameter passing (<code>Œ≤</code>-rule) (was very slow) - then also introduced call-by-value - cvn vs cbv &quot;one was correct, one was fast&quot;</p>
<p>For the next 15 years, people struggled to relate call-by-name (correct) with call-by-value (fast).</p>
<p>Landin (1960s, '62, '63), invented the idea of abstract syntax. Bohm did the same thing. McCarthy tried something similar.</p>
<p>Abelson and Sussman make popular &quot;applicative order application&quot;.</p>
<p>Dana Scott assigned a mathematical meaning to <code>Œª</code>-calculus: 1. Created the function space 2. Assigning a mapping from <code>Œª ‚Üí ‚ü¶‚üß</code></p>
<p>MF opinion, denotational semantics took us off track.</p>
<p>Plotkin solved all of this (1972/1974) &quot;Call-by-name, call-by-value and the lambda calculus&quot;. Launched enough research ideas to fill 15 people's entire research lives. Read this paper it's really good!!!</p>
<p>Gives an algorithm to understand what a calculus and a semantics is for a programming language (13 steps?).</p>
<p>Launched research into CPS.</p>
<ol style="list-style-type: decimal">
<li>Pick a term language, scoped</li>
<li>Pick a subset of terms, called programs, and another subset, called values (first appearance of words 'program' and 'value' in study of <code>Œª</code> up to that point.)</li>
</ol>
<ul>
<li>Programs are things we don't really know what to do with immediately</li>
<li><p>Values are things &quot;you see&quot; at the end of computation. <code>Œª</code> is a value.</p>
<pre><code>        .- input
 (Œªi.e) e&#39; ~~~~~~&gt; output
 -----
 ^ program proper</code></pre></li>
</ul>
<ol start="3" style="list-style-type: decimal">
<li><p>Define a notion of reduction: <code>Œ≤</code> and <code>Œ≤-value</code></p>
<p>Œ≤·µ•: (Œªx.e)v ~&gt; e[x‚Üêv]</p></li>
<li><p>Uniformly crate a calculus <code>=‚Çì</code> from the notions of reduction.</p>
<p><code>=‚Çô</code> from Œ≤ and <code>=·µ•</code> from Œ≤ and Œ≤·µ•</p></li>
</ol>
<p>A way to equating arbitrary program fragments.</p>
<ol start="5" style="list-style-type: decimal">
<li><p>Define a semantics from <code>=‚Çì</code></p>
<p>eval‚Çì ‚àà ùí´(Program √ó Value)</p>
<p>e eval‚Çì v ùëñùëìùëì e =‚Çì x</p></li>
<li><p>Prove that <code>eval‚Çì</code> is a function.</p></li>
</ol>
<p>Via Church-Rosser Lemma, <code>evalÀ£</code> is a (partial) function</p>
<pre><code>   eval‚Çì(e) ‚âî { n          for &quot;base&quot; value 
              | &#39;closure   for Œª-expression }</code></pre>
<p>You can now prove things like:</p>
<pre><code>   e (Y e) =‚Çô Y e</code></pre>
<p>Computation should be directed, which for now is not specified, and problematic.</p>
<ol start="7" style="list-style-type: decimal">
<li><p>Prove that <code>=‚Çì</code> satisfies a &quot;standardization&quot; property:</p>
<p>ùëñùëì e =‚Çì e' ùë°‚Ñéùëíùëõ then you can do so in an algorithmic fashion</p></li>
</ol>
<p>An algorithm means you know how to pick the next redex.</p>
<p>The algorithm is the same for CBN and CBV.</p>
<p>&quot;left-most outer-most strategy&quot;, ùëñ.ùëí. standard reduction. <code>|--&gt;‚Çì</code>.</p>
<p>A strategy is a meta-function for picking a redex.</p>
<p>&quot;If all you care about is the value at the end, you can use standard reduction&quot;.</p>
<pre><code>   eval‚Çì(e) = v ùëñùëìùëì e |--&gt;‚Çì* v</code></pre>
<p>Proof in Curry and Fays, Curry Fays theorem.</p>
<p>(Aside: you must give readers a guide for how to pronounce math notation! A reader should be able to read your paper aloud.)</p>
<p>We have two semantics, <code>eval‚Çì</code> based on standard reduction, and <code>=‚Çì</code> based on equality.</p>
<p>Must prove that <code>eval‚ÇìSR</code> is the same function as <code>eval‚Çì=</code>.</p>
<p>CBN calculus inconsistent with CBV interpreter, CBV calculus inconsistent with CBN interpreter.</p>
<p>What do calculations on program mean?</p>
<ol style="list-style-type: decimal">
<li>(Syntactic) because you prove Church/Rosser, you know that calculations are consistent with the &quot;fast&quot; interpreter</li>
<li>(Semantic) via snippet from Jim Morris (63) dissertation, created polymorphic lambda calculus (PAL): introduce a relation known as observational equivalence.</li>
</ol>
<p><code>e ‚âÉ e'</code> means for all ways of placing a term into a complete program (a context) called C, eval‚Çì(C[e]) ~ eval‚Çì(C[e'])</p>
<p>Two versions: <code>‚âÉ‚Çô</code> and <code>‚âÉ·µ•</code>. These are the largest possible consistent equivalence relations that let you calculate programs. Therefore they are unique (because they are larges). They are the <em>truth</em>.</p>
<p>Every programming language has &quot;the truth&quot; (<code>‚âÉ‚Çô</code>) by virtue of having an interpreter. The goal is to make the proof system (<code>=‚Çì</code>) consistent with the truth.</p>
<p>MF: &quot;On the expressive power of programming languages&quot;, previous draft attempted to prove <code>‚âÉ·µ• ‚äÜ  ‚âÉ‚Çô</code>, was proved different two months earlier.</p>
<p>CBV and CBN functional programming are not related other than in the syntax of the terms. CBN is not &quot;a different strategy&quot;.</p>
<p>Laziness and CBN are related, by subset.</p>
<p>Q: what use is studying functional programming if programs aren't purely functional?</p>
<pre><code>(f (call/cc g)) ~ g(f)</code></pre>
<p>A calculus equation for a very imperative idea.</p>
<p>Technical insights: &quot;evaluation context semantics&quot; <em>use contexts instead of inference rules</em>.</p>
<pre><code>e Œ≤ e&#39;
---------    &lt;-- inference rule
e =‚∏§Œ≤‚∏• e&#39;</code></pre>
<p>&quot;Syntactic compatibility&quot;</p>
<p>&quot;left-most-outer-most&quot;</p>
<p>Contexts:</p>
<pre><code>e ‚©¥ x | Œªx.e | e e
C ‚©¥ ‚ñ° | Œªx.C | C e | e C</code></pre>
<p>one-hole contexts.</p>
<p><code>C[e]</code> &quot;textually&quot; put <code>e</code> into hole.</p>
<pre><code>(Œªx.‚ñ°)(Œªy.y)
      
 / \
Œª  Œª‚Üê‚Üê
|  | ‚Üë
‚ñ°  ‚ãÖ‚Üí‚Üí</code></pre>
<p>with contexts:</p>
<pre><code>=‚∏§Œ≤‚∏• : e =‚∏§Œ≤‚∏• e&#39; ùëñùëìùëì  ‚àÉ C,
     e  = C[(Œªx.e‚ÇÄ)e‚ÇÅ]
     e&#39; = C[e‚ÇÄ[x ‚Üêe‚ÇÅ]]</code></pre>
<p>Evaluation context:</p>
<pre><code>E ‚©¥ ‚ñ° | E e</code></pre>
<p>Thm: E[(Œªx.e)e'] is the LMOM redex.</p>
<p>For CBV you need:</p>
<pre><code>E ‚©¥ ‚ñ° | v E | E e</code></pre>
<p>You could also use:</p>
<pre><code>E ‚©¥ ‚ñ° | e E | E v</code></pre>
<p>also left-most-outer-most!</p>
<pre><code>E[(Œªx.e)e&#39;] |--&gt;‚Çô E[e[x‚Üêe&#39;]]</code></pre>
<p>fully describes CBN standard reduction.</p>
<pre><code>E[(Œªx.e)v] |--&gt;·µ• E[e[x‚Üêv]]</code></pre>
<p>fully describes CBV standard reduction.</p>
<p>&quot;evaluation context semantics&quot; should be called &quot;standard reduction semantics&quot;.</p>
<p>Technical Insight 2:</p>
<pre><code>E[ THING v ]</code></pre>
<p><code>THING</code> can manipulate <code>E</code>, the evaluation context.</p>
<p>From this you can do side-effects, continuations, etc.</p>
<p>ùëí.ùëî.</p>
<pre><code>E[raise e] ~&gt; raise e</code></pre>
<p>full equational system for exceptions:</p>
<pre><code>x | Œªx.e | ee | raise e</code></pre>
<p>calculation system:</p>
<pre><code>C[(Œªx.e)v]    =‚Çë‚Çì C[e[x‚Üêv]]
C[E[raise e]] =‚Çë‚Çì C[raise e]</code></pre>
<p>These two rules give you a consistent Church/Rosser system for exceptions. Same two equations work for CBN.</p>
<p>Standard reduction:</p>
<pre><code>E[(Œªx.e)v]     |--&gt;‚Çë‚Çì E[e[x‚Üêv]]
E[E&#39;[raise e]] |--&gt;‚Çë‚Çì E[raise e]   [ |--&gt;‚Çë‚Çì raise e , as a coincidence  ]</code></pre>
<p>Standard reduction for assignment:</p>
<pre><code>e = x | Œªx.e | e e | set! x e | letrec ((x v) ..) e
v = Œªx.e

E = ‚ñ° | E e | v E | set! x E

(Œ≤‚Çõ‚Çë‚Çú):  (Œªx.e) v                          R  letrec ((x v)) e
(x):     letrec (.. (x v) ..) E[x]         R  letrec (.. (x v) ..) E[v]
(set!):  letrec (.. (x v) ..) E[set! x u]  R  letrec (.. (x u) ..) E[Œªx.x]

(scope extrusion:)
  E[letrec (...) e]  R  letrec (...) E[e]

(merge:)
  letrec (.. (x v) ..) (letrec (.. (y u) ..) e)  R  letrec (.. (x v) .. .. (y u) ..) e</code></pre>
<p>You can calculate in parallel, but standard reduction doesn't capture parallel execution.</p>
<p>Technical Insight 3:</p>
<pre><code>t:   E[(Œªx.e)e&#39;]   = P‚Çú
t+1: E[e[x‚Üêe&#39;]]    = P‚Çú‚Çä‚ÇÅ</code></pre>
<p>Idea: separate <code>E</code> from the expression where the &quot;machine&quot; is looking for a redex.</p>
<p>Two register machine: control and stack registers:</p>
<pre><code>‚ü®e,E‚ü©</code></pre>
<p>Next idea: change data representation from context to stack:</p>
<pre><code>‚ü®e,[app‚ÇÅ]‚ü©
   [app‚ÇÇ]
   [app‚ÇÉ]
    ...</code></pre>
<p>Next idea: substitution is hard and inefficient. Make substitution lazy; reveals an explicit environment.</p>
<pre><code>control:     e
environment: œÅ  mapping free-variables to values
stack:       Œ∫  control stack</code></pre>
</body>
</html>
